---
layout: docs
page_title: Wan Federation with Vault as Secrets Backend
description: >-
  End to end example of WAN Federation using Vault as secrets backend for Consul on Kubernetes.
---

# Wan Federation with Vault as Secrets Backend

## Overview
TODO:  DESCRIBE WHAT WE RAE DOING IN THIS END TO END EXAMPLE

## Prerequisites
TODO:  WRAP THIS INTO THE ABOVE DESCRIPTION DESCRIBING THE ENVIRONMENT

- Two Kuberentes clusters (one for each datacenter)
- Kubernetes distribution must support load balancer services (NOTE: it's possible to make it work without load balancers, but these instructions use load balancers for simplicity).

### Pre-existing Vault installation in dc1

In this setup, you will deploy Vault server in the dc1 k8s which is also the primary Consul datacenter. You will configure our Vault Helm installation in the dc2 k8s cluster to use it as an external server. This way there will be a single vault server cluster that will be use by both Consul datacenters.

For demonstration purposes, we will deploy Vault server in dev mode, although for production installations, this is not recommended. 

Target your dc1 kubernetes cluster and deploy the Vault Helm chart with the following Helm values:

```shell
$ cat <<EOF >> vault-dc1.yaml
# vault-dc1.yaml
server:
  dev:
    enabled: true
  service:
    enabled: true
    type: LoadBalancer
ui:
  enabled: true
```

```shell
$ helm install vault-dc1 -f vault-dc1.yaml hashicorp/vault --wait
```

Now you will have Vault running in dc1 as a pre-existing Vault installation prior to installing Consul.

## Systems Integation

### One time set up on Vault
#### Enable Vault KV Secrets Engine - Version 2
The following secrets will be stored in Vault KV secrets engine:
- Gossip encryption key ([`global.gossipEncryption`]())
- ACL Replication token ([`global.acls.replicationToken`](/docs/k8s/helm#v-global-acls-replicationtoken))

Therefore, we must enable the [Vault KV secrets engine - Version 2](https://www.vaultproject.io/docs/secrets/kv/kv-v2).

```shell-session
$ vault secrets enable -path=consul kv-v2
```

#### Enable Vault PKI Engine

The Vault PKI Engine must be enabled in order to leverage Vault for issuing Consul Server TLS certificates.

* Enable the PKI Secrets Engine:

  ```shell-session
  $ vault secrets enable pki
  ```

* Tune the engine to enable longer TTL:

  ```shell-session
  $ vault secrets tune -max-lease-ttl=87600h pki
  ```

* Generate the root CA

  ```shell-session
  $ vault write pki/root/generate/internal common_name="Consul CA" ttl=87600
  ```

### Set up per Consul datacenter
#### dc1 Datacenter
Set dc1 as you
##### Set Environment Variables to ensure integration consistency
    ```shell
    $ export DATACENTER=dc1
    ```

    ```shell
    export VAULT_AUTH_METHOD_NAME=kubernetes-${DATACENTER}
    ```

##### Install Vault Injector in your Consul k8s cluster
A minimal valid installation of Vault Kubernetes must include the Agent Injector which is utilized for accessing secrets from Vault. 
In dc1, we will not have to configure `injector.externalvaultaddr` value because the Vault Server is in the same dc1 cluster.

```shell
$ cat <<EOF >> vault-dc1.yaml
# vault-dc1.yaml
server:
  dev:
    enabled: true
  service:
    enabled: true
    type: LoadBalancer
ui:
  enabled: true
EOF
``` 

```shell
$ helm upgrade vault-${DATACENTER} -f vault-dc1.yaml hashicorp/vault --wait
```

##### Configure the Kubernetes Auth Method in Vault for the datacenter
###### Enable the Auth Method
Enable the Vault Kubernetes auth method.

```shell
$ vault auth enable -path=kubernetes-${DATACENTER} kubernetes
```

```shell
$ vault write auth/kubernetes-dc1/config kubernetes_host=https://kubernetes.default.svc
```

###### Configure Auth Method with JWT token of service account

First, while targeting your Consul cluster, get the externally reachable address of the Consul Kubernetes cluster.

```
$ export KUBE_API_URL=$(kubectl config view -o jsonpath="{.clusters[?(@.name == \"$(kubectl config current-context)\")].cluster.server}")
```

```shell-session
$ vault write auth/kubernetes/config \
    token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
    kubernetes_host="https://$KUBE_API_URL:443" \
    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
```

#####  Enable Vault as the secrets backend in the Consul datacenter
Finally, you will configure the Consul on Kubernetes helm chart for the dc1 datacenter to enable Vault as the Secrets backend.  However, you will not yet apply the Helm chart.  A complete chart for the dc1 datacenter is applied at the end of the Data Integration section.

<CodeBlockConfig filename="values-dc1.yaml">

```yaml
global:
  secretsBackend:
    vault:
      enabled: true
```

</CodeBlockConfig>


####  dc2 Datacenter
##### Set Environment Variables to ensure integration consistency
    ```shell
    $ export DATACENTER=dc2
    ```

    ```shell
    export VAULT_AUTH_METHOD_NAME=kubernetes-${DATACENTER}
    ```

    First, still targeting your dc1 cluster, get the external IP or DNS name of the Vault server load balancer. 

    On GKE or AKS, it'll be an IP:

    ```shell
    $ VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
    ```

    On EKS, it'll be a hostname:

    ```shell
    $ VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
    ```

    ```shell
    $ export VAULT_ADDR=http://${VAULT_SERVER_HOST}:8200
    ```

##### Install Vault Injector in your Consul k8s cluster
A minimal valid installation of Vault Kubernetes must include the Agent Injector which is utilized for accessing secrets from Vault. 
In dc2, we will have to configure `externalvaultaddr` value point to the external address of the Vault server in dc1.

Now change your Kubernetes current context to target dc2.

```shell
$ cat <<EOF >> vault-dc2.yaml
# vault-dc2.yaml
server:
  enabled: false
injector:
  enabled: true
  externalVaultAddr: $VAULT_ADDR
  authPath: auth/${VAULT_AUTH_METHOD_NAME}
EOF
``` 

```shell
$ helm install vault-${DATACENTER} -f vault-dc2.yaml hashicorp/vault --wait
```

##### Configure the Kubernetes Auth Method in Vault for the datacenter

###### Enable the Auth Method
Enable the Vault Kubernetes auth method.

```shell
$ vault auth enable -path=kubernetes-${DATACENTER} kubernetes
```

###### Create a service account with access to Kubenetes API in dc2
For the dc2 auth method, we first need to create a service account that allows Vault server in dc1 cluster to talk to the Kubernetes API in the dc2 cluster.

Target your dc2 cluster and apply the following:

```yaml
# auth-method.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-dc2-auth-method
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
- kind: ServiceAccount
  name: vault-dc2-auth-method
  namespace: default
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-dc2-auth-method
  namespace: default
```

```shell
$ kubectl apply -f auth-method.yaml
clusterrolebinding.rbac.authorization.k8s.io/vault-dc2-auth-method created
serviceaccount/vault-dc2-auth-method created
```

Next, we will need to get the token and CA cert from that service account secret.

```shell
$ K8S_DC2_CA_CERT="$(kubectl get secret `kubectl get serviceaccounts vault-dc2-auth-method -o jsonpath='{.secrets[0].name}'` -o jsonpath='{.data.ca\.crt}' | base64 -d)"

$ K8S_DC2_JWT_TOKEN="$(kubectl get secret `kubectl get serviceaccounts vault-dc2-auth-method -o jsonpath='{.secrets[0].name}'` -o jsonpath='{.data.token}' | base64 -d)"
```
###### Configure Auth Method with JWT token of service account

First, get the externally reachable address of the dc2 Consul Kubernetes cluster.

```
$ export KUBE_API_URL=$(kubectl config view -o jsonpath="{.clusters[?(@.name == \"$(kubectl config current-context)\")].cluster.server}")
```

```shell
$ vault write auth/kubernetes-dc2/config \
  kubernetes_host="${KUBE_API_URL}" \
  token_reviewer_jwt="${K8S_DC2_JWT_TOKEN}" \
  kubernetes_ca_cert="${K8S_DC2_CA_CERT}" \
```

##### Enable Vault as the secrets backend in the Consul datacenter
Finally, you will configure the Consul on Kubernetes helm chart for the dc2 datacenter to enable Vault as the Secrets backend.  However, you will not yet apply the Helm chart.  A complete chart for the dc2 datacenter is applied at the end of the Data Integration section.

<CodeBlockConfig filename="values-dc2.yaml">

```yaml
global:
  secretsBackend:
    vault:
      enabled: true
```

</CodeBlockConfig>

### Systems Integration steps are complete
You have currently set all of the configuration and set up required for Consul to utilize Vault as a secrets backend and also for Vault to be able to authenticate requests for secrets from both Consul datacenters.  

## Data Integration
### Overview
To use an Vault as the Service Mesh Certificate Provider on Kubernetes, we will need to modify the steps outlined in the [Data Integration](/docs/k8s/installation/vault/data-integration) section:

- One time set up in Vault
  1. Store the secrets in Vault.
  1. Create a Vault policy that authorizes the desired level of access to the secrets.
- Set up per Consul datacenter
  1. Create Vault Kubernetes auth roles that link the policy to each Consul on Kubernetes service account that requires access.
  1. Configure the Vault Kubernetes auth role in the Consul on Kubernetes helm chart.

### One time set up in Vault
#### Store the secrets in Vault
##### Gossip encryption key secret

```shell
$ vault kv put consul/secret/gossip key="$(consul keygen)"
```
##### Replication token secret

```shell
$ vault kv put consul/secret/replication token="$(uuidgen | tr '[:upper:]' '[:lower:]')"
```  
##### Root CA certificate
```shell
$ vault write pki/root/generate/internal common_name="Consul CA" ttl=87600
``` 
#### Create a Vault policies that authorize the desired level of access to the secrets
##### Gossip encryption key policy

```shell
$ vault policy write gossip - <<EOF
path "consul/data/secret/gossip" {
  capabilities = ["read"]
}
EOF
```

##### Replication token policy

```shell
$ vault policy write replication-token - <<EOF
path "consul/data/secret/replication" {
  capabilities = ["read"]
}
EOF
```

##### CA policy

```shell
$ vault policy write ca-policy - <<EOF
path "pki/cert/ca" {
  capabilities = ["read"]
}
EOF
```

### Set up per Consul datacenter
#### dc1 datacenter
##### Create Server TLS and Service Mesh Cert Policies
##### Server TLS Cert policy
```shell
$ vault policy write consul-cert-dc1 - <<EOF
path "pki/issue/consul-cert-dc1"
{
  capabilities = ["create","update"]
}
EOF
```

##### Service Mesh Cert policy
```shell
$ vault policy write connect-ca-dc1 - <<EOF
path "/sys/mounts" {
  capabilities = [ "read" ]
}
path "/sys/mounts/connect_root" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/sys/mounts/dc1/connect_inter" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/connect_root/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/dc1/connect_inter/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
EOF
```

##### Create Vault Kubernetes auth roles that link the policy to each Consul on Kubernetes service account that requires access
We will need to create auth roles for the consul-k8s components so that they access secrets that they will need. For each auth method in Vault, we will need roles for:

* Consul server
* Consul client
* `server-acl-init` job
* Role for Consul server CA

```shell
$ vault write auth/kubernetes-dc1/role/consul-server \
        bound_service_account_names=consul-server \
        bound_service_account_namespaces="default" \
        policies="gossip,connect-ca-dc1,consul-cert-dc1" \
        ttl=24h
```

```shell
$ vault write auth/kubernetes-dc1/role/consul-client \
        bound_service_account_names=consul-client \
        bound_service_account_namespaces="default" \
        policies="gossip" \
        ttl=24h
```
```shell
$ vault write auth/kubernetes-dc1/role/server-acl-init \
        bound_service_account_names=consul-server-acl-init \
        bound_service_account_namespaces="default" \
        policies="replication-token" \
        ttl=24h
```

```shell
$ vault write auth/kubernetes-dc1/role/consul-ca \
        bound_service_account_names="*" \
        bound_service_account_namespaces="default" \
        policies=ca-policy \
        ttl=1h
```

##### Server TLS Cert role
```shell
$ vault write pki/roles/consul-cert-dc1 \
  allowed_domains="dc1.consul,consul-server,consul-server.default,consul-server.default.svc" \
  allow_subdomains=true \
  allow_bare_domains=true \
  allow_localhost=true \
  generate_lease=true \
  max_ttl="720h"
```

##### Configure the Vault Kubernetes auth role in the Consul on Kubernetes helm chart
Now you can configure and install Consul in dc1 datacenter.

<CodeBlockConfig filename="consul-dc1.yaml">

```yaml
# consul-dc1.yaml
global:
  datacenter: "dc1"
  name: consul
  secretsBackend:
    vault:
      enabled: true
      consulServerRole: consul-server
      consulClientRole: consul-client
      consulCARole: consul-ca
      manageSystemACLsRole: server-acl-init
      connectCA:
        address: http://vault-dc1.default:8200
        rootPKIPath: connect_root/
        intermediatePKIPath: dc1/connect_inter/
        authMethodPath: kubernetes-dc1
  tls:
    enabled: true
    enableAutoEncrypt: true
    caCert:
      secretName: "pki/cert/ca"
  federation:
    enabled: true
  acls:
    manageSystemACLs: true
    createReplicationToken: true
    replicationToken:
      secretName: consul/data/secret/replication
      secretKey: token
  gossipEncryption:
    secretName: consul/data/secret/gossip
    secretKey: key
server:
  replicas: 1
  serverCert:
    secretName: "pki/issue/consul-cert-dc1"
connectInject:
  replicas: 1
  enabled: true
controller:
  enabled: true
meshGateway:
  enabled: true
  replicas: 1
```

</CodeBlockConfig>

```shell
$ helm install consul-dc1 -f consul-dc1.yaml hashicorp/consul
```

#### dc2 datacenter
##### Create Server TLS and Service Mesh Cert Policies
##### Server TLS Cert policy
```shell
$ vault policy write consul-cert-dc2 - <<EOF
path "pki/issue/consul-cert-dc2"
{
  capabilities = ["create","update"]
}
EOF
```

##### Service Mesh Cert policy
```shell
$ vault policy write connect-ca-dc2 - <<EOF
path "/sys/mounts" {
  capabilities = [ "read" ]
}
path "/sys/mounts/connect_root" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/sys/mounts/dc2/connect_inter" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/connect_root/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
path "/dc2/connect_inter/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}
EOF
```

##### Create Vault Kubernetes auth roles that link the policy to each Consul on Kubernetes service account that requires access
We will need to create auth roles for the consul-k8s components so that they access secrets that they will need. For each auth method in Vault, we will need roles for:

* Consul server
* Consul client
* `server-acl-init` job
* Role for Consul server CA

```shell
$ vault write auth/kubernetes-dc2/role/consul-server \
        bound_service_account_names=consul-server \
        bound_service_account_namespaces="default" \
        policies="gossip,connect-ca-dc2,consul-cert-dc2,replication-token" \
        ttl=24h
```

```shell
$ vault write auth/kubernetes-dc2/role/consul-client \
        bound_service_account_names=consul-client \
        bound_service_account_namespaces="default" \
        policies="gossip" \
        ttl=24h
```
```shell
$ vault write auth/kubernetes-dc2/role/server-acl-init \
        bound_service_account_names=consul-server-acl-init \
        bound_service_account_namespaces="default" \
        policies="replication-token" \
        ttl=24h
```

```shell
$ vault write auth/kubernetes-dc2/role/consul-ca \
        bound_service_account_names="*" \
        bound_service_account_namespaces="default" \
        policies=ca-policy \
        ttl=1h
```

##### Server TLS Cert role
```shell
$ vault write pki/roles/consul-cert-dc2 \
  allowed_domains="dc2.consul,consul-server,consul-server.default,consul-server.default.svc" \
  allow_subdomains=true \
  allow_bare_domains=true \
  allow_localhost=true \
  generate_lease=true \
  max_ttl="720h"
```

##### Configure the Vault Kubernetes auth role in the Consul on Kubernetes helm chart
Now you can configure and install Consul in dc2 datacenter. 
##### Set the Mesh Gateway address from DC1.
For dc2 datacenter, we will need to get the address of the mesh gateway from the **dc1** cluster.  Change your Kubernetes current context to target dc1 and set the `MESH_GW_HOST` environment variable that you will use in the Consul Helm chart for dc2 datacenter.

On GKE and AKS:

```
export MESH_GW_HOST=$(kubectl get svc consul-mesh-gateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
```

On EKS:
```
export MESH_GW_HOST=$(kubectl get svc consul-mesh-gateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
```

##### Set the Mesh Gateway address from DC1.

<CodeBlockConfig filename="consul-dc2.yaml">

```yaml
# consul-dc2.yaml
global:
  datacenter: "dc2"
  name: consul
  secretsBackend:
    vault:
      enabled: true
      consulServerRole: consul-server
      consulClientRole: consul-client
      consulCARole: consul-ca
      manageSystemACLsRole: server-acl-init
      connectCA:
        address: http://vault-dc2.default:8200
        rootPKIPath: connect_root/
        intermediatePKIPath: dc2/connect_inter/
        authMethodPath: kubernetes-dc2
  tls:
    enabled: true
    enableAutoEncrypt: true
    caCert:
      secretName: "pki/cert/ca"
  federation:
    enabled: true
  acls:
    manageSystemACLs: true
    createReplicationToken: true
    replicationToken:
      secretName: consul/data/secret/replication
      secretKey: token
  gossipEncryption:
    secretName: consul/data/secret/gossip
    secretKey: key
server:
  replicas: 1
  serverCert:
    secretName: "pki/issue/consul-cert-dc2"
connectInject:
  replicas: 1
  enabled: true
controller:
  enabled: true
meshGateway:
  enabled: true
  replicas: 1
```

</CodeBlockConfig>

Change your Kubernetes current context to target dc1 and use the above values files for you helm install:

```shell
$ helm install consul-dc2 -f consul-dc2.yaml hashicorp/consul
```

### Secondary Datacenters

To configure Vault as the Connect CA in secondary datacenters, you need to make sure that the Root CA path is the same,
but the intermediate is different for each datacenter. In the `connectCA` Helm configuration for a secondary datacenter,
you can specify a `intermediatePKIPath` that is, for example, prefixed with the datacenter
for which this configuration is intended (e.g. `dc2/connect-intermediate`).

